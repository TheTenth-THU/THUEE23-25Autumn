## 关系数据理论的描述

### 关系模式

先前已有提及，[[关系数据库#^GuanxiMoshi|关系模式]]可归结为一个**五元组 $\mathscr{R}(U,D,\mathrm{dom},F)$**，其中：
+ $\mathscr{R}$ 是关系名，表示元组语义；
+ $U = \{A_{1}, A_{2}, \cdots, A_{n}\}$ 是**属性集**，$n$ 是关系的度，表示元组的结构；
+ $D = \{D_{1}, D_{2}, \cdots, D_{n}\}$ 是**域集**，$D_{i}$ 是属性 $A_{i}$ 的域，表示属性的数据类型；
+ $\mathrm{dom}\colon U \rightarrow D$ 是**属性向域的映像集合**，$\mathrm{dom}(A_{i}) = D_{i}$，表示属性与域的对应关系；
+ $F$ 是属性间**数据的依赖关系**集合，表示属性间的约束条件。

其中 $D$、$\mathrm{dom}$ 主要与数据的存储和表示有关，与**模式的逻辑结构设计**关系不大，此处可简记为**三元组 $\mathscr{R}(U,F)$**。

数据依赖 $F$ 有多种形式，如**[[#函数依赖]] (functional dependency, FD)**、**[[#多值依赖]] (multivalued dependency, MVD)**、**[[#连接依赖]] (join dependency, JD)** 等。

### 函数依赖

> [!definition] 函数依赖 
> 设有关系模式 $\mathscr{R}(U,F)$，$X, Y \subseteq U$。如果在关系 $\mathscr{R}$ 的**任意一个合法实例**中，对于任意两个元组 $t_{1}$ 和 $t_{2}$，只要 $t_{1}$ 和 $t_{2}$ 在属性集 $X$ 上的值相等，就必然在属性集 $Y$ 上的值也相等，则称**属性集 $Y$ 函数依赖 (functionally dependent) 于属性集 $X$**，记作 $X \to Y$。

函数依赖不是指关系模式的某个或某些关系满足的约束条件，而是**关系模式的全部关系均要满足**的约束条件。

#### 函数依赖的术语

进一步地，我们给出下面术语：
+ 若 $X \to Y$，则称 $X$ 为**决定因素 (determinant)**，$Y$ 为**被决定因素 (dependent)**；
+ 若 $X \to Y$ 且 $Y \subseteq X$，则称为**平凡的函数依赖 (trivial FD)**，否则（$Y \not\subseteq X$）称为**非平凡的函数依赖 (non-trivial FD)**；
+ 若 $X \to Y$ 且 $Y \to X$，则称 $X$ 与 $Y$ 为**等价属性集 (equivalent attribute sets)**，记作 $X \leftrightarrow Y$；
+ 若 $X \to Y$，并且对于 $X$ 的任一真子集 $X' \subset X$，均有 $X' \not\to Y$，则称 $Y$ 对 $X$ **完全函数依赖 (full FD)**，记作 **$X \xrightarrow{\mathrm{F}} Y$**，否则称为**部分函数依赖 (partial FD)**，记作 **$X \xrightarrow{\mathrm{P}} Y$**；
+ 若 $X \to Y$（$Y \not\subseteq X$，$Y \not\to X$）且 $Y \to Z$（$Z \not\subseteq Y$），则称 $Z$ 对 $X$ **传递函数依赖 (transitive FD)**，记作 **$X \xrightarrow{\mathrm{T}} Z$**。

#### 极小函数依赖集

> [!def.] 极小函数依赖集
> 设关系模式 $\mathscr{R}(U,F)$ 的函数依赖集 $F$ 满足：
> 1. $F$ 中任一函数依赖的右部均为单属性；
> 2. $F$ 中不存在这样的函数依赖 $X \to A$，使得 $F$ 与 $F - \{X \to A\}$ 等价，即 **$F$ 无冗余函数依赖**；
> 3. $F$ 中不存在这样的函数依赖 $X \to A$，使得 $X$ 有真子集 $X' \subset X$，且 $F$ 与 $F - \{X \to A\} \cup \{X' \to A\}$ 等价，即 **$F$ 无冗余决定因素**。
> 
> 则称 $F$ 为关系模式 $\mathscr{R}(U)$ 的**极小函数依赖集 (minimal FD set)**。

显然，**每一个函数依赖集都等价于一个极小函数依赖集**，极小函数依赖集是函数依赖集的一种规范化形式，便于分析关系模式的结构和性质。

极小化函数依赖集的一般步骤为：
1. 将函数依赖集 $F$ 中每个函数依赖的**右部拆分成单属性**，即将每个 $X \to Y$（$Y = \{A_{1}, A_{2}, \cdots, A_{m}\}$）替换为 $m$ 个函数依赖 $X \to A_{1}, X \to A_{2}, \cdots, X \to A_{m}$；
2. 逐一检查函数依赖集中的每个函数依赖 $X \to A$，判断其**冗余性**，即检查 $F - \{X \to A\}$ 是否等价于 $F$，如果等价则删除该函数依赖，否则保留；
3. 逐一检查函数依赖集中的每个函数依赖 $X \to A$，判断其**决定因素的冗余性**，即检查是否存在 $X$ 的真子集 $X' \subset X$，使得 $F - \{X \to A\} \cup \{X' \to A\}$ 等价于 $F$，如果存在则将该函数依赖替换为 $X' \to A$，否则保留。

#### 关系的码

现在可以用函数依赖来描述[[关系数据库#关系的码|关系的码]]的定义，即：对于关系模式 $\mathscr{R}(U,F)$，如果属性集 $K \subseteq U$ 满足 $K \xrightarrow{\mathrm{F}} U$，则 $K$ 为**候选码 (candidate key)**。由此容易理解，可能存在多个候选码，从中任选一个作为**主码 (primary key)**；也可能只有**整个属性集 $U$ 本身**作为唯一的候选码，称为**全码 (whole key)**。

若 $K \xrightarrow{\mathrm{P}} U$，则称 $K$ 为**超码 (super key)**。显然超码一定包含候选码，但候选码的真子集一定不是超码。

### 多值依赖

> [!definition] 多值依赖
> 设有关系模式 $\mathscr{R}(U)$，$X, Y, Z \subseteq U$，$Z = U - X - Y$。如果对于 $\mathscr{R}(U)$ 的任一关系 $\mathscr{r}$，给定 $(X, Z)$ 的值 $(x, z)$，有一组 $Y$ 的值与之对应，其仅决定于 $x$，而与 $z$ 无关，则称**属性集 $Y$ 多值依赖 (multivalued dependent) 于属性集 $X$**，记作 **$X \twoheadrightarrow Y$**。
> 
> **等价表述**：设有关系模式 $\mathscr{R}(U)$，$X, Y, Z \subseteq U$，$Z = U - X - Y$。对于关系模式 $\mathscr{R}(U)$ 的任一关系 $\mathscr{r}$，如果对于任意两个元组 $t$、$s$，当 $t[X]=s[X]$ 时在 $\mathscr{r}$ 中必存在元组 $u$、$v$，使得 $u[X]=v[X]=t[X]$，而 $u[Y]=t[Y]$、$u[Z]=s[Z]$，$v[Y]=s[Y]$、$v[Z]=t[Z]$，则称 $Y$ 多值依赖于 $X$，记作 $X \twoheadrightarrow Y$。

多值依赖具有以下性质：
+ 在 $\mathscr{R}(U)$ 中，若 $X \twoheadrightarrow Y$，则 $X \twoheadrightarrow Z$，其中 $Z = U - X - Y$，即多值依赖有**对称性**；
+ 在 $\mathscr{R}(U)$ 中，若 $X \to Y$，则 $X \twoheadrightarrow Y$，即函数依赖**蕴含**多值依赖，是多值依赖的一种特殊情况；
+ 在 $\mathscr{R}(U)$ 中，若 $Z = U - X - Y = \varnothing$，则必然有 $X \twoheadrightarrow Y$，称之为**平凡多值依赖 (trivial MVD)**。

### 连接依赖

考虑将关系模式 $\mathscr{R}(U,F)$ 投影分解为 $\mathscr{X}(X, F_{\mathscr{X}})$、$\mathscr{Y}(Y, F_{\mathscr{Y}})$ 两个子模式，$F_{\mathrm{FD}} \subset F$ 是 $\mathscr{R}$ 的**函数依赖**集，如果 $F_{\mathrm{FD}}^{+} = (F_{\mathscr{X}} \cup F_{\mathscr{Y}})^{+}$，且对于 $\mathscr{R}$ 的任一合法实例 $\mathscr{r}$ 都有
$$
\mathscr{r} = \Pi_{X}(\mathscr{r}) \bowtie \Pi_{Y}(\mathscr{r})
$$
则我们称这一分解相对于 $F_{\mathrm{FD}}$ 是**无损连接分解 (lossless join decomposition)**。

> [!definition] 连接依赖
> 设有关系模式 $\mathscr{R}$ 的**无损连接分解**为 $\{ \mathscr{R}_{1}, \mathscr{R}_{2}, \cdots, \mathscr{R}_{n} \}$，则记 $\join\limits_{i=1}^{n} R_{i}$ 为关系模式 $\mathscr{R}$ 的**连接依赖 (join dependency, JD)**。

MVD $X \twoheadrightarrow Y$ 可视为连接依赖的一种特殊情况，即关系模式 $\mathscr{R}(U)$ 的连接依赖 $\join\limits_{i=1}^{2} R_{i}$，其中 $\mathscr{R}_{1}(\{X, Y\})$、$\mathscr{R}_{2}(\{X, Z\})$，$Z = U - X - Y$。相应地，如果在连接依赖 $\join\limits_{i=1}^{n} R_{i}$ 中，存在 $\mathscr{R}_{i} = \mathscr{R}$，则称之为**平凡连接依赖 (trivial JD)**。 

## 关系模式的规范化

关系模式的规范化是指通过分析关系模式中的函数依赖，消除数据冗余和异常，得到更合理的关系模式结构的过程。规范化通常分多级**范式 (normal form)**，每个范式都有相应的定义和要求。

### 第一范式 (1NF)

> [!definition] 第一范式
> 如果关系模式 $\mathscr{R}(U,F)$ 的每个属性都是**原子的（不可分的）**，则称 $\mathscr{R}$ 满足**第一范式 (first normal form, 1NF)**，记作 $\mathscr{R}\in \text{1NF}$。

1NF 是对[[关系数据库#^Guifanhua|规范化关系]]的最基本的要求，确保每个属性的值都是不可再分的基本数据项。

考虑下面的**关系模式 $\mathscr{S}(\{ \underline{\text{SNO}, \text{CN}}, \text{SN}, \text{SD}, \text{MN}, \text{G} \}, F)$**：
$$
\begin{align}
F\colon \qquad&\text{SNO} \to \text{SN}, \qquad (\text{SNO}, \text{CN}) \xrightarrow{\mathrm{P}} \text{SN}, \\
&\text{SNO} \to \text{SD}, \qquad (\text{SNO}, \text{CN}) \xrightarrow{\mathrm{P}} \text{SD}, \\
&\text{SNO} \to \text{MN}, \qquad \text{SD} \to \text{MN}, \qquad (\text{SNO}, \text{CN}) \xrightarrow{\mathrm{P}} \text{MN}, \\
&(\text{SNO}, \text{CN}) \xrightarrow{\mathrm{F}} \text{G}
\end{align}
$$
这一关系模式表示学生选课，其中 SNO 表示学生学号，SN 表示学生姓名，SD 表示系别，MN 表示系主任姓名，CN 表示课程名称，G 表示成绩。

![[1NF.png|1NF 关系示例]]

作为一个仅满足 1NF 的关系模式，其中存在如下问题：
+ **数据冗余**：学生的姓名、系别、系主任等信息在每条选课记录中重复存储，浪费存储空间。
+ **插入异常**：如果要添加一个新学生但该学生尚未选课，则无法插入该学生的信息，因为 CN 不能为空。
+ **删除异常**：如果删除某个学生的所有选课记录，则该学生的所有信息也会丢失。
+ **更新繁复**：如果院系系主任发生变更，则需要更新所有该学生的选课记录；如果学生转系，也需要更新所有选课记录。

解决上述问题的方式是**投影分解**，将所有**部分函数依赖**拆分出去，得到更合理的关系模式结构。

### 第二范式 (2NF)

> [!definition] 第二范式
> 设关系模式 $\mathscr{R}(U,F) \in \text{1NF}$，且其任一非主属性均**完全函数依赖于码**，则称 $\mathscr{R}$ 满足**第二范式 (second normal form, 2NF)**，记作 $\mathscr{R}\in \text{2NF}$。

考虑将关系模式 $\mathscr{S}$ 投影分解为两个关系模式：
+ $\mathscr{S}_{1}(\{ \underline{\text{SNO}}, \text{SN}, \text{SD}, \text{MN} \}, F_{1})$ 表示**学生信息**，其中 $F_{1} = \{ \text{SNO} \to \text{SN}, \text{SNO} \to \text{SD}, \text{SD} \to \text{MN} \}$；
+ $\mathscr{S}_{2}(\{ \underline{\text{SNO}, \text{CN}}, \text{G} \}, F_{2})$ 表示**学生选课信息**，其中 $F_{2} = \left\{ (\text{SNO}, \text{CN}) \xrightarrow{\mathrm{F}} \text{G} \right\}$。

这样，$\mathscr{S}_{1}$ 和 $\mathscr{S}_{2}$ 均满足 2NF，消除了数据冗余和插入、删除异常。

![[2NF.png|2NF 关系示例]]

由上图，$\mathscr{S}_{1}$ 中有**传递函数依赖** $\text{SNO} \to \text{SD} \to \text{MN}$，仍然存在数据冗余等问题，如：
+ **数据冗余**：系主任姓名在每条学生记录中重复存储，浪费存储空间。
+ **插入异常**：如果要添加一个新系但该系尚无学生，则无法插入该系的信息，因为 SNO 不能为空。
+ **删除异常**：如果删除某个系的所有学生记录，则该系的信息也会丢失。
+ **更新繁复**：如果系主任发生变更，则需要更新所有该系的学生记录。

解决上述问题的方式依旧是**投影分解**，将所有**传递函数依赖**拆分出去，得到更合理的关系模式结构。

### 第三范式 (3NF)

> [!definition] 第三范式
> 设关系模式 $\mathscr{R}(U,F) \in \text{1NF}$，且 $\mathscr{R}$ 中**不存在**这样的**码 $X$**、属性组 $Y$ 和**非主属性 $Z \not\subseteq Y$**，使得 **$X \to Y$，$Y \to Z$，$Y \not\to X$**，则称 $\mathscr{R}$ 满足**第三范式 (third normal form, 3NF)**，记作 $\mathscr{R}\in \text{3NF}$。

3NF 要求每个非主属性**只能依赖于码**，既无部分依赖，也无传递依赖。

将上述关系模式 $\mathscr{S}_{1}$ 再行投影分解为两个关系模式：
+ $\mathscr{S}_{11}(\{ \underline{\text{SNO}}, \text{SN}, \text{SD} \}, F_{11})$ 表示**学生基本信息**，其中 $F_{11} = \{ \text{SNO} \to \text{SN}, \text{SNO} \to \text{SD} \}$；
+ $\mathscr{S}_{12}(\{ \underline{\text{SD}}, \text{MN} \}, F_{12})$ 表示**系别信息**，其中 $F_{12} = \{ \text{SD} \to \text{MN} \}$。

这样，$\mathscr{S}_{11}$、$\mathscr{S}_{12}$ 和 $\mathscr{S}_{2}$ 均满足 3NF，彻底消除了数据冗余和插入、删除异常。

![[3NF.png|3NF 关系示例]]

### Boyce-Codd 范式 (BCNF)

> [!definition] Boyce-Codd 范式
> 设关系模式 $\mathscr{R}(U,F) \in \text{1NF}$，且其任一函数依赖 $X \to Y$（$Y \not\subseteq X$）均满足 **$X$ 包含有码**，则称 $\mathscr{R}$ 满足 **Boyce-Codd 范式 (Boyce-Codd normal form, BCNF)**，记作 $\mathscr{R}\in \text{BCNF}$。

BCNF 中，每个决定因素都包含码，进一步加强了 3NF 的要求。一个满足 BCNF 的关系模式满足：
+ 所有非主属性对每一个码都是完全函数依赖的；
+ 所有主属性对每一个不包含它的码，也都是完全函数依赖的；
+ 没有任何一组属性完全函数依赖于非码的任何一组属性。

> [!example] 3NF 但非 BCNF 的关系模式
> 考虑下面的关系模式 $\mathscr{STJ}(\{ \underline{\text{S}, \text{T}}, \text{J} \}, F)$ 表示**学生 S、教师 T 和所教课程 J** 之间的关系，语义是：
> + 每一个教师只教一门课，每门课可有若干教师，即 $\text{T} \to \text{J}$；
> + 某一学生选定某门课，就对应一个固定教师，即 $(\text{S}, \text{J}) \xrightarrow{\mathrm{F}} \text{T}$。
> 
> 即函数依赖集为 $F= \{ \text{T} \to \text{J}, (\text{S}, \text{J}) \to \text{T}, (\text{S}, \text{T}) \to \text{J} \}$。$(\text{S}, \text{J})$ 和 $(\text{S}, \text{T})$ 均为候选码，因此 S、T、J 均为主属性，不存在**非主属性**对码的传递依赖或部分依赖，因此 $\mathscr{STJ} \in \text{3NF}$。然而，函数依赖 $\text{T} \to \text{J}$ 的**决定因素 T 不包含码**，故 $\mathscr{STJ} \notin \text{BCNF}$。

BCNF 又称**修正的第三范式 (modified 3NF)**，是对 3NF 的加强，因此只满足 3NF 而不满足 BCNF 的关系模式仍可能存在冗余和异常，如上例中指定某教师 T 授课 J，但因为学生还没选修，信息就无法输入到数据库中，存在**插入异常**。

解决上述问题的方式依旧是**投影分解**，将违反 BCNF 的函数依赖拆分出去，得到更合理的关系模式结构。如上例，可将关系模式 $\mathscr{STJ}$ 投影分解为两个关系模式 $\mathscr{TJ}(\{ \underline{\text{T}}, \text{J} \}, \{ \text{T} \to \text{J} \})$、$\mathscr{ST}(\{ \underline{\text{S}, \text{T}} \}, \varnothing)$。

![[BCNF.png|BCNF 关系示例]]

BCNF 完全消除了在[[#函数依赖]]条件下的冗余依赖关系。

### 第四范式 (4NF)

考虑如下 BCNF 关系模式 $\mathscr{WSC}(\{ \underline{\text{W}, \text{S}, \text{C}} \}, F)$，表示仓库 W、保管员 S 和货品 C 之间的关系，语义是：
+ 每个仓库可由多个保管员负责，每个保管员可负责多个仓库；
+ 每个仓库可存放多种货品，每种货品可存放在多个仓库中；
+ 每个保管员管理所在仓库的所有货品。

即函数依赖集为 $F = \{ \text{W} \twoheadrightarrow \text{S}, \text{W} \twoheadrightarrow \text{C} \}$。显然，$\mathscr{WSC}$ 满足 BCNF，但由于存在**多值依赖**，仍然存在数据冗余和异常问题，如：
+ **数据冗余**：每个仓库的保管员和货品信息在每条记录中重复存储，浪费存储空间。
+ **插入异常**：如果要添加一个新仓库但该仓库尚无保管员或货品，则无法插入该仓库的信息，因为 S 和 C 不能为空。
+ **删除异常**：如果删除某个仓库的所有货品，则该仓库的保管员信息也会丢失。
+ **更新繁复**：如果某个仓库的保管员发生变更，则需要更新所有该仓库的记录。

为此，针对多值依赖引入第四范式。

> [!definition] 第四范式
> 设关系模式 $\mathscr{R}(U,F) \in \text{1NF}$，且其任一非平凡多值依赖 $X \twoheadrightarrow Y$ 均满足 **$X$ 包含有码**，则称 $\mathscr{R}$ 满足**第四范式 (fourth normal form, 4NF)**，记作 $\mathscr{R}\in \text{4NF}$。

将上述关系模式 $\mathscr{WSC}$ 投影分解为两个关系模式：
+ $\mathscr{WS}(\{ \underline{\text{W}, \text{S}} \}, \{ \text{W} \twoheadrightarrow \text{S} \})$ 表示**仓库与保管员关系**；
+ $\mathscr{WC}(\{ \underline{\text{W}, \text{C}} \}, \{ \text{W} \twoheadrightarrow \text{C} \})$ 表示**仓库与货品关系**。

$\text{W} \twoheadrightarrow \text{S}$ 和 $\text{W} \twoheadrightarrow \text{C}$ 都是平凡的多值依赖，因此 $\mathscr{WS}$ 和 $\mathscr{WC}$ 均满足 4NF。

### 第五范式 (5NF)

> [!definition] 第五范式
> 设关系模式 $\mathscr{R}(U,F) \in \text{1NF}$，且其任一非平凡连接依赖 $\join\limits_{i=1}^{n} R_{i}$ 均由 $\mathscr{R}$ 的 FD 集 $F_{\mathrm{FD}}$ 决定，且 $F_{\mathrm{FD}}$ 的左边均包含有码，则称 $\mathscr{R}$ 满足**第五范式 (fifth normal form, 5NF)**，记作 $\mathscr{R}\in \text{5NF}$。

5NF 又称为**投影连接范式 (projection-join normal form, PJNF)**，是对连接依赖的规范化要求，确保关系模式中的每个连接依赖都可以通过其函数依赖集来决定，消除冗余和异常。

Date 和 Fagin 给出，若关系模式 $\mathscr{R}(U,F) \in \text{3NF}$ 的**每个码均为单属性**，则 $\mathscr{R}$ 必然满足 5NF。