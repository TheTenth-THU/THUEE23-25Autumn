## 资源切分

多用户通信专注于讨论简单拓扑结构下**多个信息流（收发对）共享通信资源（时，频等）的方法**，包括多址（局域网）和复接（广域网）。

**多址 (multi access) 通信**是局域网的核心知识，典型的局域网拓扑包括：

![[局域网拓扑.png]]

广域网的长距离传输，为提效、降成本，常把多个用户的信息流通过共同的光纤、铜缆、卫星、微波中继传输，称为**复接 (multiplexing)**。

![[广域网拓扑.png]]

无论是多址，还是复接，本质上都依赖于对通信资源的划分，又称**信道化 (channelization)**。

### 时分与频分多址

**时分多址 (time division multiple access, TDMA)** 是将时间划分为多个时隙，不同用户在不同的时隙内发送数据，从而实现多个用户共享同一频带；**频分多址 (frequency division multiple access, FDMA)** 是将频带划分为多个子信道，不同用户在不同的子信道内发送数据，从而实现多个用户同时传输数据。

TD 与 FD 实现简洁，且可以混用，如第 2 代移动通信中的 D-AMPS 系统。

> [!remark] 题型：TDMA、FDMA 与物理层参数
> **典型题型**　给定多址系统的部分网络层参数（用户数 $N$、用户数据速率 $R_{\mathrm{b}}$）和物理层参数（总带宽 $B$、滚降系数 $\alpha$），求 TDMA/FDMA 方案（载频 $f_{i}$、调制阶数 $M$）。
> 
> 仍然是欠定问题，不妨先分解 $N = n_{\mathrm{T}}n_{\mathrm{F}}$，每个 $\cfrac{B}{n_{\mathrm{F}}}$ 宽的频带有 $n_{\mathrm{T}}$ 个时隙，需要承载 $n_{\mathrm{T}}R_{\mathrm{b}}$ 的速率。由[[载波传输#^ShengyuxianDaitongDianxingKaofa|带通升余弦系统]]的知识可知，调制阶数 $M$ 满足
> $$
> \cfrac{n_{\mathrm{T}} R_{\mathrm{b}}}{\dfrac{\log M}{1+\alpha}} \le \dfrac{B}{n_{\mathrm{F}}} \implies \log M \ge \dfrac{n_{\mathrm{T}} n_{\mathrm{F}} R_{\mathrm{b}} (1+\alpha)}{B} = \dfrac{N R_{\mathrm{b}} (1+\alpha)}{B}
> $$
> 由此可确定调制阶数 $M$，且其与 $N$ 的分解方式无关。
> 
> $M$ 确定后，对应于 $n_{\mathrm{T}}$ 可得升余弦的实际带宽 $B_{n_{\mathrm{T}}} = \cfrac{n_{\mathrm{T}} R_{\mathrm{b}}}{\log M} (1+\alpha)$，从而可确定各载频 $f_{i}$ 使得各频带尽量分散。
> 
> 反过来，如果已知对各子频带的带宽有要求，则可以据此确定所能支持的用户数 $n_{\mathrm{T}}$，从而确定总用户数 $N$ 的分解方式。

### 时分复接

**时分复接 (time division multiplexing, TDM)** 是将时间划分为多个时隙，不同用户在不同的时隙内发送数据，从而实现多个用户共享同一频带。TDM 与 TDMA 的区别在于，TDM 强调**多个用户的信息流分时隙接入同一个设备**，而 TDMA 强调**多个用户分时隙共享同一个信道**。

## 访问控制

### Aloha

#### 纯 Aloha

Aloha 是夏威夷大学开发的无线多址协议，基本思想是**随机接入 (random access)**，即用户在有数据发送时**随机选择时间**发送数据。发送后，
+ 若无冲突，接收方发送确认 (ACK)，发送方收到 ACK 后结束传输；
+ 若有冲突，发送方在**随机等待一段时间**后重新发送数据。

![[Aloha.png]]

由于 Aloha 中采用**定长分组**，记帧长为 $b$ 个 bit，传输速率为 $R_{\mathrm{b}}$ (bit/s)，则每帧传输时间为 $T_{\mathrm{fr}} = \cfrac{b}{R_{\mathrm{b}}}$。定义 Aloha 系统的**供给业务量** $G$ 为**每帧**时间内「尝试传输」的平均次数，则单位时间内「尝试传输」的平均次数即**总帧生成率**为 $\lambda_{\mathrm{t}} = \cfrac{G}{T_{\mathrm{fr}}}$；再记**成功传输概率**（无任何碰撞的概率）为 $p_{\mathrm{suc}}$，则单位时间内成功传输的平均次数为 $\lambda_{\mathrm{t}} p_{\mathrm{suc}}$。

给出一个引理：大量独立同分布更新过程的叠加为一个 Poisson 过程。因此，对于海量用户，记每个用户单位时间内尝试接入的次数即**用户帧生成率**为 $\lambda_{\mathrm{u}}$，则所有用户的**总帧生成率**为 $\lambda_{\mathrm{t}} = N \lambda_{\mathrm{u}}$。换言之，
+ 单个用户的尝试（帧）到达率 $\lambda_{\mathrm{u}} = \cfrac{\lambda _\mathrm{t}}{N} \xrightarrow{N \to +\infty} 0$；
+ 对任意一个给定的用户来说，其看到的「背景业务」（其他用户的尝试）到达率为 $(N - 1) \lambda_{\mathrm{u}} \approx \cfrac{N-1}{N} \lambda_{\mathrm{t}} \xrightarrow{N \to +\infty} \lambda_{\mathrm{t}}$。

这样，对于任意一个给定的用户来说，其看到的**背景业务到达过程**为**参数为 $\lambda_{\mathrm{t}}$ 的 Poisson 过程**。本用户在时间 $t$ 发送一帧数据，若在**脆弱时间 (vulnerable time) $[t - T_{\mathrm{fr}}, t + T_{\mathrm{fr}}]$** 内有其他用户发送数据，则会发生碰撞，导致发送失败。由于背景业务到达过程为参数为 $\lambda_{\mathrm{t}}$ 的 Poisson 过程，因此在该时间段内没有其他用户发送数据的概率为
$$
p_{\mathrm{suc}} = \Pr \left\{ N(2T_{\mathrm{fr}}) = 0 \right\} = \e^{-2 \lambda_{\mathrm{t}} T_{\mathrm{fr}}} = \e^{-2G}
$$

> [!theorem] Aloha 系统的吞吐量
> 海量用户 Aloha 系统在单位时间内成功传输的帧数即**帧吞吐量**为
> $$
> \lambda = \lambda_{\mathrm{t}} \e^{-2\lambda_{\mathrm{t}} T_{\mathrm{fr}}} = \dfrac{G}{T_{\mathrm{fr}}} \cdot \e^{-2G}
> $$
> **比特吞吐量**为
> $$
> \lambda_{\mathrm{b}} = \lambda b = R_{\mathrm{b}} G \e^{-2G}
> $$
> 其传输速率 $R_{\mathrm{b}}$ 中被有效利用的比例即**归一化吞吐量**为
> $$
> \rho = \dfrac{\lambda_{\mathrm{b}}}{R_{\mathrm{b}}} = G \e^{-2G}
> $$

#### 时隙 Aloha

**时隙 Aloha (slotted Aloha)** 是对 Aloha 的改进，假设所有用户**时间同步**，将时间划分为多个时隙，用户只能在**时隙开始**时发送数据。

![[时隙 Aloha.png]]

这样，脆弱时间缩短为 $T_{\mathrm{fr}}$，成功传输概率变为
$$
p_{\mathrm{suc}} = \Pr \left\{ N(T_{\mathrm{fr}}) = 0 \right\} = \e^{-\lambda_{\mathrm{t}} T_{\mathrm{fr}}} = \e^{-G}
$$
或者，每个用户在一个时隙内的发送概率为 $p = \lambda_{\mathrm{u}} T_{\mathrm{fr}} = \cfrac{\lambda_{\mathrm{t}}T_{\mathrm{fr}}}{N} = \cfrac{G}{N}$，则在该时隙内有且仅有一个用户发送数据的概率为
$$
N p_{\mathrm{u},\mathrm{suc}} = N \cdot p (1 - p)^{N - 1} = G \left( 1 - \dfrac{G}{N} \right)^{N-1} \xrightarrow{N \to +\infty} G \e^{-G}
$$

> [!theorem] 时隙 Aloha 系统的吞吐量
> 海量用户时隙 Aloha 系统的**帧吞吐量**为
> $$
> \lambda = \lambda_{\mathrm{t}} \e^{-\lambda_{\mathrm{t}} T_{\mathrm{fr}}} = \dfrac{G}{T_{\mathrm{fr}}} \cdot \e^{-G}
> $$
> **比特吞吐量**为
> $$
> \lambda_{\mathrm{b}} = \lambda b = R_{\mathrm{b}} G \e^{-G}
> $$
> 其**归一化吞吐量**为
> $$
> \rho = \dfrac{\lambda_{\mathrm{b}}}{R_{\mathrm{b}}} = G \e^{-G}
> $$

> [!remark] 题型：Aloha 与时隙 Aloha
> **典型题型 1**　对于海量用户 Aloha 与时隙 Aloha 系统，求最能有效利用信息速率 $R_{\mathrm{b}}$ 的供给业务量 $G$、帧生成率 $\lambda_{\mathrm{t}}$、帧长 $b$ 或帧传输时间 $T_{\mathrm{fr}}$。
> 
> + 纯 Aloha 对 $\rho = G\e^{-2G}$ 求导得到 $G^{*} = \cfrac{1}{2}$，此时 $\rho_{\mathrm{max}} = \cfrac{1}{2\e} \approx 0.184$。
> + 时隙 Aloha 对 $\rho = G\e^{-G}$ 求导得到 $G^{*} = 1$，此时 $\rho_{\mathrm{max}} = \cfrac{1}{\e} \approx 0.368$。
> 
> 确定 $G$ 后，可由约束 $\lambda_{\mathrm{t}} T_{\mathrm{fr}} = G$、$T_{\mathrm{fr}} = \cfrac{b}{R_{\mathrm{b}}}$ 求解出相应的参数。
> 
> ---
> 
> **典型题型 2**　给定 Aloha 或时隙 Aloha 系统的部分参数（如单用户帧生成率 $\lambda_{\mathrm{u}}$、帧长 $b$ 等）与部分物理层参数（如工作频率），求对通信链路速率 $R_{\mathrm{b}}$ 利用率最高的物理层参数（如滚降系数 $\alpha$、调制阶数 $M$）。
> 
> 由 $G^{*} = 0.5$ 或 $1$，结合 $\lambda_{\mathrm{t}} = N \lambda_{\mathrm{u}}$ 和 $T_{\mathrm{fr}} = \cfrac{b}{R_{\mathrm{b}}}$ 可得
> $$
> R_{\mathrm{b}}^{*} = \dfrac{N \lambda_{\mathrm{u}} b}{G^{*}}
> $$
> 结合物理层速率表达式（如带宽 $B$、调制阶数 $M$、滚降系数 $\alpha$ 等），即可求解出最优物理层参数。

### 载波侦听 (CSMA)

**载波侦听多址 (carrier sense multiple access, CSMA)** 是对 Aloha 的进一步改进，用户在发送数据前**先监听信道**，若信道空闲则发送数据，若信道忙碌则等待一段随机时间后重新监听。CSMA 可分为三种类型：
+ **非坚持 CSMA (non-persistent CSMA)**：信道忙碌时，用户等待一段随机时间后重新监听信道；
+ **1-坚持 CSMA (1-persistent CSMA)**：信道忙碌时，用户持续监听信道，直至信道空闲后立即发送数据；
+ **$p$-坚持 CSMA ($p$-persistent CSMA)**：适用于时隙化信道，信道空闲时，用户以概率 $p$ 发送数据，以概率 $1-p$ 等待下一个时隙。

#### CSMA/CD 与以太网

以太网的核心协议**带冲突检测的载波侦听 (CSMA with collision detection, CSMA/CD)** 是基于 CSMA 的改进。其基本思想是，用户在发送数据时**持续监听信道**，若检测到冲突，则**立即停止发送**。

为了更好地「通知」全网发生了冲突，在检测到冲突时发送一个**冲突信号 (jamming signal)**。以太网**有线媒介的封闭特性**决定了对于网中任意节点发送的信号在其它各节点处侦听的功率近似相同，这使得可以很容易地区分**信道空闲**、**信道忙碌**和**信道冲突** 3 种状态，从而实现载波侦听。

设网络中最大传播时间为 $\tau$，则
+ 为了确保发送节点能够检测到冲突，需有**帧长 $T_{\mathrm{fr}} > 2\tau$**；
+ 自上一帧传完起，**经过 $\tau$ 时间**后最远的节点也**确认信道空闲**，此时才开始竞争；
+ 每次竞争耗时 $2\tau$ （从发送节点发送信号到最远节点，再从最远节点返回发送节点），可设**经过 $k$ 次竞争**后成功。

这样，传输 1 帧的平均耗时为
$$
\mathbb{E} \left[ T \right] = \mathbb{E} \left[ T_{\mathrm{fr}} + \tau + 2\tau k \right] = T_{\mathrm{fr}} + \tau + 2\tau \mathbb{E} \left[ k \right]
$$
可记 $a = \cfrac{\tau}{T_{\mathrm{fr}}}$，则（总有用户试图尝试接入时）**CSMA/CD 的效率**为
$$
\eta = \dfrac{T_{\mathrm{fr}}}{\mathbb{E} \left[ T \right]} = \dfrac{1}{1 + a (1 + 2 \mathbb{E} \left[ k \right])}
$$

设用户尝试接入的概率为 $q$，则一个竞争时隙内有且仅有一个用户发送数据的概率为
$$
\gamma = N q (1 - q)^{N - 1}
$$
知 $q = \cfrac{1}{N}$ 时，$\gamma$ 取最大值 $\gamma_{\mathrm{max}} = \left( 1 - \cfrac{1}{N} \right)^{N - 1} \xrightarrow{N \to +\infty} \cfrac{1}{\e}$。因此，**平均竞争次数**为
$$
\mathbb{E} \left[ k \right] = \sum_{k=1}^{+\infty} k \cdot (1 - \gamma)^{k-1} \gamma = \dfrac{1}{\gamma} \xrightarrow{N \to +\infty} \e
$$
代入效率表达式，得到 **CSMA/CD 的效率极限**为
$$
\eta_{\mathrm{max}} = \dfrac{1}{1 + a (1 + 2\e)} \approx \dfrac{1}{1 + 6.44a}
$$

#### CSMA/CA 与无线局域网

**带冲突避免的载波侦听 (CSMA with collision avoidance, CSMA/CA)** 是对 CSMA 的改进，适用于无线局域网。由于无线信道的**开放特性**，节点难以区分**信道忙碌**和**信道冲突**，因此 CSMA/CD 不适用于无线局域网。CSMA/CA 通过引入**确认机制 (acknowledgment)** 和**随机退避 (random backoff)** 来避免冲突。

具体而言，CSMA/CA 的工作流程如下：
1. 发送方监听信道，若信道忙碌则等待一段随机时间后重新监听，若信道空闲则发送**请求发送 (RTS, Request to Send)** 帧；
2. 接收方收到 RTS 帧后，若信道空闲则发送**允许发送 (CTS, Clear to Send)** 帧，通知发送方可以发送数据；
3. 发送方收到 CTS 帧后，发送数据帧；
4. 接收方收到数据帧后，发送确认 (ACK) 帧；
5. 发送方收到 ACK 帧后结束传输。

在 CSMA/CA 中，RTS、CTS 和 ACK 帧帮助网络内用户**虚拟侦听 (virtual carrier sensing)**，从而避免冲突的发生。

### 交换

交换任务是星型网络上、下行链路的核心。为了提高链路利用率，常采用**多级交换结构**，使用多个小规模的交叉开关 (crossbar) 组成大规模交换机。

设有一 $N$ 进 $N$ 出的交换需求，则
+ **完全交叉开关 (full crossbar switch)** 需要 $N^{2}$ 个交叉点 (crosspoint)，成本高昂。
+ 若 $N = n^{2}$，则可采用**两级交换结构**，使用 $n$ 个 $n$ 进 $n$ 出的交叉开关作为第一阶段，另 $n$ 个 $n$ 进 $n$ 出的交叉开关作为第二阶段，总共需要 $2n \cdot n^{2} = 2N^{1.5}$ 个交叉点，成本大幅降低。
+ 若 $N$ 被正整数 $n$ 整除，则可采用**三级交换结构**，使用 $\cfrac{N}{n}$ 个 $n$ 进 $k$ 出交叉开关作为第一阶段，$k$ 个 $\cfrac{N}{n}$ 进 $\cfrac{N}{n}$ 出交叉开关作为第二阶段，另 $\cfrac{N}{n}$ 个 $k$ 进 $n$ 出交叉开关作为第三阶段，总共需要 $2kN + k \cfrac{N^{2}}{n^{2}}$ 个交叉点，成本进一步降低。

![[交换.png]]

## 广域组网

人们希望在大的空间尺度 (Tele-) 上实现广泛 (anywhere, anytime, anyone, anything) 的连接 (communication)，从而形成**广域网 (wide area network, WAN)**。广域网通常由多个局域网通过路由器互联而成，覆盖范围广泛，支持长距离通信。

广域网的拓扑结构相对时域网复杂而多样，可以用有权（甚至有向）图 $G = (V,E)$ 来表示，边 $(i,j)$ 的权重 $C(i,j)$ 表示从节点 $i$ 到节点 $j$ 的**传输开销 (cost)**，如时延、跳数、带宽消耗、经济费用等。

无论是电话网抑或计算机网，因为**鲁棒性需要**和**自组织建设**而常**有环**，于是从信源到信宿可能有大量可行的路径，需要找寻一条最优路径。要求这一寻路算法：
1. 易扩展（面向生长中的大型网络）；
2. 分布式（尽量减少信令交互）；
3. 动态自适应（于网络状态变化）；
4. 收敛快。

### Bellman-Ford 算法与距离矢量协议

**Bellman-Ford 算法**是一种分布式的最短路径算法，其基本思想是通过**动态规划**的方式，逐步更新各节点到目标节点的最短路径估计值，直到收敛为止。每个节点仅需**与其直接邻居交换信息**，从而实现分布式计算。基于 Bellman-Ford 算法，设计提出了**距离矢量路由协议 (distance vector routing protocol)**，如 RIP（路由信息协议）。

> [!algo.] 基于 Bellman-Ford 的距离矢量路由
> 距离矢量协议的基本思想是每个节点 $i$ 维护一个**距离矢量 (distance vector)** $\v{D}_{i} = ( D_{i}(1), D_{i}(2), \ldots, D_{i}(|V|) )$，其中 $D_{i}(j)$ 表示节点 $i$ 到节点 $j$ 的当前最短路径估计值。
> 
> ---
> 
> **GIVEN —** 
> + 图 $G = (V,E)$ 及其边权重 $C(i,j)$；
> + 本地节点 $a$。
>   
> **INITIALIZE —**
> 1. 对每个节点 $i \in V$，设置 $D_{a}(i) = \begin{cases} 0, & i = a, \\ C(a,i), & (a,i) \in E, \\ +\infty, & \text{otherwise} \end{cases}$。
> 2. 将 $\v{D}_{a}$ 发送给所有邻居节点。
> 
> **REPEAT —**
> 当收到邻居节点 $b$ 发送的距离矢量 $\v{D}_{b}$ 时，
> 1. 对每个节点 $i \in V$，计算通过邻居 $b$ 到达节点 $i$ 的路径长度 $D_{a}^{\text{new}}(i) = C(a,b) + D_{b}(i)$；
> 2. 若 $D_{a}^{\text{new}}(i) < D_{a}(i)$，则更新 $D_{a}(i) = D_{a}^{\text{new}}(i)$，同时对应记录下一跳节点为 $b$。
> 
> 若有变化，将更新后的距离矢量 $\v{D}_{a}$ 发送给所有邻居节点。
> 
> **OUTPUT —**
> 最终的距离矢量 $\v{D}_{a}$，表示节点 $a$ 到所有节点的最短路径估计值，以及对应目标节点的下一跳节点。

Bellman-Ford 算法的优点在于其**分布式**和**易扩展**的特性，适用于大型动态网络。然而，其缺点也很明显：当网络链路变化甚至断线后，可能出现**计数发散 (count to infinity)**，即距离估计值不断增大，导致收敛缓慢。

### Dijkstra 算法与链路状态协议

**Dijkstra 算法**是一种集中式的最短路径算法，其基本思想是通过**贪心策略**，逐步扩展已知最短路径的节点集合，直到找到从源节点到所有节点的最短路径。基于 Dijkstra 算法，设计提出了**链路状态路由协议 (link state routing protocol)**，如 OSPF（开放最短路径优先）。

> [!algo.] 基于 Dijkstra 的链路状态路由
> 链路状态协议的基本思想是每个节点 $i$ 维护一个**链路状态数据库 (link state database)**，包含网络中所有节点及其连接关系和边权重信息。
> 
> ---
> 
> **GIVEN —**
> + 图 $G = (V,E)$ 及其边权重 $C(i,j)$；
> + 本地节点 $a$。
> 
> **INITIALIZE —**
> 1. 设置已知最短路径节点集合 $S = \{ a \}$；
> 2. 对每个节点 $i \in V$，设置 $D_{a}(i) = \begin{cases} 0, & i = a, \\ C(a,i), & (a,i) \in E, \\ +\infty, & \text{otherwise} \end{cases}$。
> 
> **REPEAT —**
> 1. 从 $V \setminus S$ 中选择距离 $D_{a}(j)$ 最小的节点 $j$，将其加入集合 $S$；
> 2. 对每个节点 $i \in V \setminus S$，计算通过节点 $j$ 到达节点 $i$ 的路径长度 $D_{a}^{\text{new}}(i) = D_{a}(j) + C(j,i)$；
> 3. 若 $D_{a}^{\text{new}}(i) < D_{a}(i)$，则更新 $D_{a}(i) = D_{a}^{\text{new}}(i)$，同时对应记录下一跳节点为 $j$。
> 
> 　**UNTIL —** $S = V$。
> 
> **OUTPUT —**
> 最终的距离矢量 $\v{D}_{a}$，表示节点 $a$ 到所有节点的最短路径估计值，以及对应目标节点的下一跳节点。

