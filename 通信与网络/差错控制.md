## 差错控制概述

### 差错控制的位置

差错控制的位置可以分为两类：
+ 在**物理层**、**链路层**实现的差错控制，主要用于检测和纠正**点到点**传输过程中产生的随机差错。
+ 在**传输层**实现的差错控制，主要用于检测和纠正**端到端**传输过程中产生的差错。

下面主要讨论**传输层**的差错控制，即默认**中间一系列节点不可靠**，在发端和收端之间进行差错控制。

### 典型的差错控制方案

#### 反馈确认

在收端 $D$ 收到数据后，将收到的 bit 原样返回给发端 $S$，发端 $S$ 将收到的 bit 与发送的 bit 进行比较，如果一致则认为数据正确接收，发送下一个 bit 组；否则认为数据出错，重新发送该 bit 组。

这种方案的问题在于：
1. 反馈确认需要额外的带宽资源；
2. 反馈确认增加了传输延迟，时间效率低；
3. 反馈信道本身也可能出错，导致误判。

#### 检错重发 (Automatic Repeat reQuest, ARQ)

在发端 $S$ 发送数据时，附加一些冗余信息（如**校验和、CRC 校验码**等），收端 $D$ 在收到数据后进行检错，如果发现数据有误，则请求发端重发该数据。典型的 ARQ 协议有**[[#「停—等」重传机制|停—等 ARQ]]**、**连续 ARQ**等。

#### 前向纠错 (Forward Error Correction, FEC)

在发端 $S$ 发送数据时，附加足够的冗余信息，使得收端 $D$ 即使在部分数据出错的情况下，也能通过冗余信息恢复出正确的数据，而无需请求重发。

### 码本的检错、纠错能力

信息 bit 串经过编码映射为传输**码字 (codeword)**，码字的集合连同其编码的映射关系构成**码本 (codebook)**。本课程中，将信息 bit 串和码字均视为 $GF_{2}$ 上的**行向量**，以 $\v{m}$、$\v{c}$ 标记。此后的向量记号亦均指行向量。

> [!example] $(1,3)$ 冗余码本的检错、纠错能力
> 考虑如下码本：
> $$
> 1 \longrightarrow 111 = \v{1}_{3}, \qquad
> 0 \longrightarrow 000 = \v{0}_{3}
> $$
> + 以 ARQ 方式处理，110、101、011、100、001、010 均可被检测为出错，但无法纠正，即**检 2 位错**而不纠错；
> + 以 FEC 方式处理，110、101、011 认为是 1，100、001、010 认为是 0，即**纠 1 位错**。
> 
> 对同一个串的处理不同，其检错、纠错能力也不同，检错与纠错不完全兼容。

两个 bit 串之间对应位相异 bit 的个数体现了其「相似」的程度，称为 **Hamming 距离 (Hamming distance)**，记为 $d$。上述检错、纠错的位数，实际也是指 Hamming 距离。

![[码本的检错、纠错能力.png]]

在一般码本中，考虑任意两个码字之间 Hamming 距离的**最小值** $d_{\text{min}} = \min\limits_{\v{c}_{1} \neq \v{c}_{2}} d(\v{c}_{1}, \v{c}_{2})$，即**最小 Hamming 距离**或**码距 (code distance)**。这个距离上，码本的检错、纠错能力与上图类似，即有

> [!theorem] 码本的纠错位数、检错位数与码距的关系
> 给定码距 $d_{\text{min}}$ 的码本，其纠错位数 $t$ 和检错位数 $e$ 满足
> $$
> t + e \leq d_{\text{min}} - 1
> $$
> 进而，
> + 纠错位数 $t$ 满足 $2t + 1 \leq d_{\text{min}}$，
> + 检错位数 $e$ 满足 $e + 1 \leq d_{\text{min}}$。

## 检错码的构造与应用

### 奇偶校验

#### 简单奇偶校验

最简单的**检错**方式是**奇偶校验 (parity check)**，即在信息 bit 串后附加一个**校验位 (parity bit)**，使得整个码字中 1 的个数为偶数。

设给定 $k$ bits 长信息 $\v{m} = \begin{pmatrix}m_{1} & m_{2} & \cdots & m_{k}\end{pmatrix}$，则编码后的码字为
$$
c_{i} = \begin{cases}
m_{i}, & i = 1, 2, \cdots, k, \\
\sum\limits_{j=1}^{k} m_{j}, & i = k + 1
\end{cases}
\quad \text{i.e.} \quad
\v{c} = \v{m} \begin{pmatrix}
1 & 0 & \cdots & 0 & 1 \\
0 & 1 & \cdots & 0 & 1 \\
\vdots & \vdots & \ddots & \vdots & \vdots \\
0 & 0 & \cdots & 1 & 1
\end{pmatrix}
$$
即 $\v{c} = \v{m} \boldsymbol{G}$，**生成矩阵 (generator matrix)** $\boldsymbol{G} = \begin{pmatrix}\boldsymbol{I}_{k}  & \v{1}_{k}\end{pmatrix}$。解码时，应有
$$
\sum\limits_{i=1}^{k+1} c_{i} = \v{c} \cdot \v{1}_{k+1} = \v{c} \v{1}_{k+1}^{\mathrm{T}} = 0
$$
即**校验矩阵 (parity-check matrix)** $\boldsymbol{H} = \v{1}_{k+1}$，当接收码字 $\v{y}$ 满足 $\v{y} \boldsymbol{H}^{\mathrm{T}} \neq 0$ 时，认为码字出错。

该码字的**码距 $d_{\text{min}} = 2$**，因此必有 $t = 0$，只能**检 1 位错**，**不能纠错**。同时，还有发生差错但无法检出的情况，**漏检概率**为
$$
p_{\mathrm{m}} = \sum\limits_{i=1}^{\lfloor (k+1)/2 \rfloor} \binom{k+1}{2i} P_{\mathrm{b}}^{2i} (1 - P_{\mathrm{b}})^{k + 1 - 2i}
$$

#### 循环冗余校验

**循环冗余校验 (cyclic redundancy check, CRC)** 是奇偶校验的推广，通过**多项式除法**实现**检错**。

[[#简单奇偶校验]]因其只有 1 位校验位，检错能力有限。我们希望通过增加更多的校验位，提高检错能力。设信息 bit 串 $\v{m}$ 可表示为**信息多项式 (message polynomial)**
$$
m(x) = m_{0} + m_{1} x + m_{2} x^{2} + \cdots + m_{k-1} x^{k-1}
$$
我们选择一个**生成多项式 (generator polynomial)** $g(x)$，其次数为**校验位长度** $n - k$，即
$$
g(x) = g_{0} + g_{1} x + g_{2} x^{2} + \cdots + x^{n-k}
$$
编码后的码字 $\v{c}$ 对应的**码字多项式 (codeword polynomial)** 设为
$$
c(x) = \underbrace{ m(x) x^{n-k} }_{ \alpha(x) } + \underbrace{ m(x) x^{n-k} \bmod g(x) }_{ \gamma(x) }
$$
其中 $\gamma(x)$ 为**校验多项式 (check polynomial)**，即移位后的信息多项式 $\alpha(x)$ 除以生成多项式 $g(x)$ 的**余数**。

由此，存在多项式 $\beta(x)$ 使得
$$
\alpha(x) = \beta(x) g(x) + \gamma(x) \quad \Longrightarrow \quad c(x) = \beta(x) g(x)
$$
即**码字多项式 $c(x)$ 可被生成多项式 $g(x)$ 整除**。解码时，收端收到 $\v{y}$ 对应码字多项式 $y(x) = c(x) + e(x)$，只需计算 $y(x) \bmod g(x)$，若结果不为零，则认为码字出错。

### ARQ 传输方案

[[#检错重发 (Automatic Repeat reQuest, ARQ)]] 是一大类典型差错控制方案，其通过**检错码**实现。

#### 「停—等」重传机制

在 ARQ 差错控制中，常用的重传机制是**停—等 (stop-and-wait)** 机制，即每发送一个数据包后，必须等待确认收到该数据包的反馈后，才能发送下一个数据包。

不妨设码本将 $k$ bits 信息映射为 $n$ bits 码字，ARQ 过程为：
1. 发端 $S$ 将信息编码为码字 $\v{c}$ 并发送，**发送用时 $T_{\mathrm{m}} = \cfrac{n}{R_{\mathrm{b}}}$**；
2. 信息从发端 $S$ 传输到收端 $D$，**传输时延为 $T_{\mathrm{d}}$**；
3. 收端 $D$ **经 $T_{\mathrm{c}}$ 时间检测**出码字 $\v{c}$ 是否正确接收，若正确则发送 **ACK (acknowledgement) 报文**，否则发送 **NACK (negative acknowledgement) 报文**，**发送用时 $T_{\mathrm{a}} = \cfrac{n_{\mathrm{a}}}{R_{\mathrm{b}}}$**；
4. ACK/NACK 报文从收端 $D$ 经同样的传输时延 $T_{\mathrm{d}}$ 传输到发端 $S$，发端据此决定是否重传该码字，决定用时忽略不计。

![[停等重传.png]]

一个 ARQ 轮次中，除开发送码字的时间 $T_{\mathrm{m}}$ 外，其余时间均为等待时间，**总等待时间**为 $T_{\mathrm{dca}} = 2 T_{\mathrm{d}} + T_{\mathrm{c}} + T_{\mathrm{a}}$。因此，即使一轮次传输成功，其时间效率也为
$$
\xi' = \frac{T_{\mathrm{m}}}{T_{\mathrm{m}} + T_{\mathrm{dca}}} = \frac{T_{\mathrm{m}}}{T_{\mathrm{m}} + 2 T_{\mathrm{d}} + T_{\mathrm{c}} + T_{\mathrm{a}}}
$$
未检出错误即为「成功」，概率为
$$
p_{\mathrm{suc}} = (1 - P_{\mathrm{b}})^{n} + p_{\mathrm{m}}
$$
其中 $p_{\mathrm{m}}$ 为**漏检概率 (missed detection probability)**，即发生差错但未被检出的概率。

成功所需轮次服从**几何分布 (geometric distribution)**，其期望为 $\cfrac{1}{p_{\mathrm{suc}}}$，因此实际时间效率为
$$
\xi = \cfrac{T_{\mathrm{m}}}{(T_{\mathrm{m}} + T_{\mathrm{dca}}) \cdot \dfrac{1}{p_{\mathrm{suc}}}} = \xi' p_{\mathrm{suc}}
$$
对上层**信息 bit 流**的整体**服务速率**即为
$$
r = \cfrac{k}{\dfrac{n}{R_{\mathrm{b}}} \cdot \dfrac{1}{\xi}} = \dfrac{k}{n} \xi R_{\mathrm{b}} = \dfrac{k ((1-P_{\mathrm{b}})^{n} + p_{m})}{n} \cdot \dfrac{R_{\mathrm{b}} T_{\mathrm{m}}}{T_{\mathrm{m}} + 2 T_{\mathrm{d}} + T_{\mathrm{c}} + T_{\mathrm{a}}}
$$

#### 选择重传机制

在[[#「停—等」重传机制]]下，发端在等待 ACK/NACK 报文期间**处于闲置状态**，时间效率较低。为提高时间效率，可采用**选择重传 (selective repeat)** 机制，即发端在等待 ACK/NACK 报文的同时，**继续发送**后续码字。

![[选择重传.png]]

选择重传机制将码字的传输与 ACK/NACK 报文的传输拆分为**独立信道**，从而**并行**进行，提高时间效率。对**固定、已知的 $T_{\mathrm{d}}$、$T_{\mathrm{c}}$**，发端可由 NACK 时间反推出出错的码字，收端由自身的报文发送记录也可推知哪个码字是重传码字，**无需序号**。

选择重传中每个码字传输的差错性能与[[#「停—等」重传机制]]相同，同样有
$$
p_{\mathrm{suc}} = (1 - P_{\mathrm{b}})^{n} + p_{\mathrm{m}}
$$
因为发端**持续发送**码字，单位时间内成功发送的消息 bit 数为 $\cfrac{k}{n} R_{\mathrm{b}} p_{\mathrm{suc}}$，即对信息 bit 流的整体服务速率为
$$
r = \dfrac{k}{n} ( (1 - P_{\mathrm{b}})^{n} + p_{\mathrm{m}} ) R_{\mathrm{b}}
$$
若**不忽略 ACK/NACK 报文的传输开销**，则服务速率为 
$$
r = \dfrac{T_{\mathrm{m}}}{T_{\mathrm{m}} + T_{\mathrm{a}}} \cdot \dfrac{k}{n} ( (1 - P_{\mathrm{b}})^{n} + p_{\mathrm{m}} ) R_{\mathrm{b}}
$$

#### 回溯 $N$ 重传机制

选择重传需要差错分组的序号判断和乱序重排，不仅复杂，而且在 $T_{\mathrm{d}}$ 未知或时变时无法正确工作。为此，可采用**回溯 $N$ 重传 (go-back-$N$ ARQ)** 机制，即发端持续发送码字，但一旦收到 NACK 报文，则**回溯重传**从该码字开始的后续 $N$ 个码字。

> [!note] 重传机制在链路层、传输层的使用
> 重传机制在链路层（单跳）和传输层（多跳）都有使用，但从发出一个分组到接收其 ACK/NACK 的**往返时间 (RTT)** 的分布特性不同。
> + 链路层通常采用**停—等 ARQ**，因为链路层传输距离短，时延小，且链路层设备通常较简单，适合使用简单的停—等 ARQ；
> + 传输层通常采用**选择重传 ARQ** 或混合 ARQ 机制，因为传输层传输距离长，时延大，且传输层设备通常较复杂，适合使用复杂的重传策略。

## 纠错码的构造与应用

### FEC 传输方案

除 ARQ 外，[[#前向纠错 (Forward Error Correction, FEC)]] 是另一大类典型差错控制方案，其通过**纠错码**（又称信道编码）实现。

依据对信息流的处理方式的不同，FEC 所构造的纠错码可分为两类：
+ **分组码 (block code)**，即将信息 bit 流划分为若干个**固定长度**的信息 bit 组，分别进行编码，形成固定长度的码字进行传输，各个码字之间编、译码相互独立。$(k, n)$ 分组码本质上是从 $GF_{2}^{k}$ 到 $GF_{2}^{n}$ 的映射，将信息分散到更大的离散空间中，从而提高抗差错能力。
	分组码又分为：
	+ **线性分组码 (linear block code)**，即编码映射是**线性映射**。线性分组码存在**生成矩阵 (generator matrix)** $\boldsymbol{G}$ 使得码字 $\v{c} = \v{m} \boldsymbol{G}$。
		线性分组码的一个重要性质是其码字集合构成 $GF_{2}^{n}$ 的**子空间 (subspace)**，从而可通过**校验矩阵 (parity-check matrix)** $\boldsymbol{H}$ 定义合法码字的集合，即 $\v{c} \boldsymbol{H}^{\mathrm{T}} = \v{0}$。
		线性分组码又可进一步分出：
		+ **线性系统码 (linear systematic code)**，其码字 $\v{c}$ 固定后 $n-k$ 位为校验位，前 $k$ 位与信息 $\v{m}$ 相同，即**生成矩阵 $\boldsymbol{G}_{k\times n} = \begin{pmatrix}\boldsymbol{I}_{k}  & \boldsymbol{P}_{k\times(n-k)}\end{pmatrix}$**，**校验矩阵 $\boldsymbol{H}_{(n-k)\times n} = \begin{pmatrix}\boldsymbol{P}_{(n-k)\times k}^{\mathrm{T}} & \boldsymbol{I}_{n-k}\end{pmatrix}$**。
		+ 线性非系统码，如 $\boldsymbol{G} = \begin{pmatrix}1 & 1 & 0 & 1 & 0 & 1 \\ 1 & 0 & 1 & 0 & 1 & 0 \\ 0 & 1 & 0 & 1 & 0 & 1\end{pmatrix}$。
	+ 非线性码，即编码映射不是线性映射，如「以 1 的计数为校验位」的码字映射。
+ **非分组码**，即对信息 bit 流进行**连续**编码，形成连续的码字流进行传输，码字之间编、译码相互关联。
	非分组码的例子有：
	+ **卷积码 (convolutional code)**，即通过有限状态机对信息 bit 流进行编码，将整个信息流与某 bit 串进行卷积运算；
	+ **Turbo 码**（或译为**涡轮码**），即通过两个或多个卷积码并行编码，并通过**交织 (interleaver)** 实现码字之间的关联，提高纠错能力。

> [!remark] 题型：线性系统码
> **典型题型**　给出 $(k, n)$ 线性系统码的若干个 $\v{m} \mapsto \v{c}$ 映射对，求其生成矩阵 $\boldsymbol{G}$ 和校验矩阵 $\boldsymbol{H}$，再由未知信息串计算码字，或由未知码字校验是否为合法码字。
> 
> 由于 $(k, n)$ 线性系统码的生成矩阵 $\boldsymbol{G}_{k\times n} = \begin{pmatrix}\boldsymbol{I}_{k}  & \boldsymbol{P}_{k\times(n-k)}\end{pmatrix}$ 中只有 $\boldsymbol{P}$ 未知，可由给出的映射对求出 $\boldsymbol{P}$，进而求出 $\boldsymbol{G}$ 和 $\boldsymbol{H}$。

### Hamming 码

#### Hamming 码的构造

我们希望构造一种**简洁的代数运算方式**，从 $\v{y} = \v{x} + \v{e}$ 中在某一条件下确定 $\v{e}$，从而恢复 $\v{x}$。

假定 $\v{e}$ 中最多只有 1 位错，即我们讨论的目标就是**纠 1 位错**，不考虑多于 1 位错的情况。由线性码性质 $\boldsymbol{G}\boldsymbol{H}^{\mathrm{T}} = \v{0}$，有
$$
\v{m} \boldsymbol{G} \boldsymbol{H}^{\mathrm{T}} = \v{c} \boldsymbol{H}^{\mathrm{T}} = \v{0}
$$
于是，因合法码字 $\v{x} \in \left\{ \v{c} \mid \v{c} \in \mathcal{C} \right\}$，有
$$
\v{y} \boldsymbol{H}^{\mathrm{T}} = (\v{x} + \v{e}) \boldsymbol{H}^{\mathrm{T}} = \v{x} \boldsymbol{H}^{\mathrm{T}} + \v{e} \boldsymbol{H}^{\mathrm{T}} = \v{0} + \v{e} \boldsymbol{H}^{\mathrm{T}} = \v{e} \boldsymbol{H}^{\mathrm{T}}
$$
即**接收码字的综合 (syndrome)** 或称**校正子 (syndrome)** $\v{s} = \v{y} \boldsymbol{H}^{\mathrm{T}}$ 仅与误码 $\v{e}$ 有关，与原码字 $\v{x}$ 无关，显然有
$$
\v{s} = \v{e} \boldsymbol{H}^{\mathrm{T}}
$$

我们希望通过 $\v{s}$ 唯一确定 $\v{e}$，从而恢复 $\v{x}$。由于我们假定 $\v{e}$ 中最多只有 1 位错，$\v{e}$ 只能是如下形式之一：
+ **无错**，$\v{e} = \v{0}$，$\v{s} = \v{0} \boldsymbol{H}^{\mathrm{T}} = \v{0}$；
+ **第 $i$ 位错**，$\v{e} = \vu{u}_i$，$\v{s} = \vu{u}_{i} \boldsymbol{H}^{\mathrm{T}} = \boldsymbol{H}^{\mathrm{T}}(i,:)$ 为矩阵 $\boldsymbol{H}^{\mathrm{T}}$ 的第 $i$ 行。

为了使 $\v{s}$ 能唯一对应 $\v{e}$，矩阵 $\boldsymbol{H}^{\mathrm{T}}$ 的各行必须互不相同，且不能为零行。注意到，$\boldsymbol{H}$ 是一个 $(n-k) \times n$ 矩阵，因此 $\boldsymbol{H}^{\mathrm{T}}$ 有 $n$ 行，每行有 $n-k$ 位，可表示的非零行共有 $2^{n-k} - 1$ 种，因此必须满足
$$
2^{n-k} - 1 = n\quad\Longrightarrow\quad n + 1 = 2^{n-k}
$$
即 $n$ 和 $k$ 必须满足上述关系，才能构造出能够纠 1 位错的线性码。这类码称为**Hamming 码**，其校验位个数为 $m = n - k$。

| $m = n - k$ | $(n, k)$ 组合 |
| :---------- | ----------- |
| 2           | $(3, 1)$    |
| 3           | $(7,4)$     |
| 4           | $(15,11)$   |
| 5           | $(31, 26)$  |

#### Hamming 码的码距

我们讨论 Hamming 码的码距 $d^{\text{min}}_{\mathrm{H}}$。任何满足 $\v{c} \boldsymbol{H}^{\mathrm{T}} = \v{0}$ 都是**合法码字**，据此知：
+ 显然 $\v{0}$ 是合法码字；
+ 不存在**只有 1 位为 1** 的合法码字，因为 $\boldsymbol{H}^{\mathrm{T}}$ 的各行均不为零；
+ 不存在**只有 2 位为 1** 的合法码字，因为任意两行之和均不为零。

另一方面，$\boldsymbol{H}^{\mathrm{T}}$ 的行遍历了 $GF_{2}^{n-k}$ 中的非零点，任意两行之和也在其中，因此 $\forall i, j$，$\exists l$ 满足 $\boldsymbol{H}^{\mathrm{T}}(l,:) = \boldsymbol{H}^{\mathrm{T}}(i,:) + \boldsymbol{H}^{\mathrm{T}}(j,:)$，即
$$
(\vu{u}_{i} + \vu{u}_{j} + \vu{u}_{l}) \boldsymbol{H}^{\mathrm{T}} = \boldsymbol{H}^{\mathrm{T}}(i,:) + \boldsymbol{H}^{\mathrm{T}}(j,:) + \boldsymbol{H}^{\mathrm{T}}(l,:) = \v{0}
$$
故存在 $\vu{u}_{i} + \vu{u}_{j} + \vu{u}_{l}$ 是一个**有 3 位为 1** 的合法码字。

因此，任何非零码字与 $\v{0}$ 的汉明距离最小为 3，又由于 $d_{\mathrm{H}}\left( \v{c}_{1}, \v{c}_{2} \right) = d_{\mathrm{H}}\left( \v{0}, \v{c}_{1} + \v{c}_{2} \right)$，故任意两个不同码字之间的汉明距离最小也为 3，即 Hamming 码的码距为 3。

> [!theorem] Hamming 码的码距
> Hamming 码的码距 $d^{\text{min}}_{\mathrm{H}} = 3$。

> [!remark] 题型：Hamming 码
> **典型题型 1**　给定信源的消息 bit 速率 $R_{\mathrm{b}}$，求 $(n,k)$ Hamming 码编码后的滚降系数 $\alpha$ 和许用电平数 $M$。
> 
> 编码后，需要的 bit 速率提升为 $R'_{\mathrm{b}} = \cfrac{n}{k} R_{\mathrm{b}}$，然后将 $R'_{\mathrm{b}}$ 代入[[载波传输#^ShengyuxianJidaiDianxingkaofa|基带升余弦系统]]或[[载波传输#^ShengyuxianDaitongDianxingKaofa|带通升余弦系统]]相关公式中，求出相应的滚降系数 $\alpha$ 和许用电平数 $M$。
> 
> ---
> 
> **典型题型 2**　给定 $P_{\mathrm{b}}$，求 $(n,k)$ Hamming 码纠错失败的概率，即误块率 $P_{\mathrm{e}}$。
> 
> 误块率 $P_{\mathrm{e}}$ 即为**发生 2 位或以上差错**的概率
> $$
> P_{\mathrm{e}} = 1 - (1 - P_{\mathrm{b}})^{n} - n P_{\mathrm{b}} (1 - P_{\mathrm{b}})^{n-1} = \sum\limits_{i=2}^{n} \binom{n}{i} P_{\mathrm{b}}^{i} (1 - P_{\mathrm{b}})^{n-i}
> $$

### 交织

当出现突发差错时，单个码字中可能出现多位差错，超出纠错码的纠错能力，导致纠错失败。为此，可通过**交织 (interleaving)** 技术将突发差错扩散到多个码字中，从而提高纠错码的有效性。

![[交织.png]]

通常使用**块交织 (block interleaver)**，即将若干个码字**按行填入**一个矩阵，然后**按列读出**形成交织后的码字流。
+ 交织块的宽度或列数 $N$ 通常取**分组码的码长 $n$**；
+ 交织块的高度或行数 $M$ 称为**交织深度 (interleaving depth)**，通常取决于信道的突发差错特性，决定了相邻码元交织后的间隔。

若分组码的纠错能力为 $n = N$ 位中的 $t$ 位错，交织后纠错能力提升为 $MN$ 位中的 $Mt$ 位错。
